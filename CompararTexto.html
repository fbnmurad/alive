<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-javascript.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-markup.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-xml-doc.min.js"></script>
<script>
  document.querySelectorAll('input[name="theme"]').forEach(el => {
    el.addEventListener('change', function() {
      const dark = this.value === 'escuro';
      document.body.classList.toggle('dark', dark);
      document.getElementById('prism-theme').disabled = dark;
      document.getElementById('prism-theme-dark').disabled = !dark;
      setTimeout(() => Prism.highlightAll(), 10);
    });
  });

  let compareMode = "linha";
  let mergeChoices = [];

  document.querySelectorAll('input[name="cmp"]').forEach(el => {
    el.addEventListener('change', function() {
      compareMode = this.value;
      mergeChoices = []; // Zera estado!
      renderDiff();
      updateMergeResult();
    });
  });

  // Helpers diff
  function diffSeq(a, b, splitFn) {
    const A = splitFn(a), B = splitFn(b);
    let m = A.length, n = B.length;
    let dp = Array(m+1).fill().map(()=>Array(n+1).fill(0));
    for(let i=m-1;i>=0;--i)for(let j=n-1;j>=0;--j)
      dp[i][j]=A[i]===B[j]?1+dp[i+1][j+1]:Math.max(dp[i+1][j],dp[i][j+1]);
    let i=0, j=0, resA="", resB="";
    while(i<m && j<n){
      if(A[i] === B[j]) {
        resA += A[i]; resB += B[j]; i++; j++;
      } else if(dp[i+1][j] >= dp[i][j+1]) {
        if(A[i].trim()!=="") resA += `<del class="diff-removed">${A[i]}</del>`;
        else resA += A[i];
        i++;
      } else {
        if(B[j].trim()!=="") resB += `<ins class="diff-added">${B[j]}</ins>`;
        else resB += B[j];
        j++;
      }
    }
    while(i<m) { if(A[i].trim()!=="") resA += `<del class="diff-removed">${A[i]}</del>`; else resA += A[i]; i++; }
    while(j<n) { if(B[j].trim()!=="") resB += `<ins class="diff-added">${B[j]}</ins>`; else resB += B[j]; j++; }
    return [resA, resB];
  }
  function diffWords(a, b) { return diffSeq(a, b, s => s.split(/(\s+)/)); }
  function diffChars(a, b) { return diffSeq(a, b, s => s.split('')); }

  function diffLineByLine(a, b) {
    const aLines = a.split('\n');
    const bLines = b.split('\n');
    const maxLen = Math.max(aLines.length, bLines.length);
    let sample = (aLines.join('\n')+bLines.join('\n')).slice(0,1500);
    let lang = detectLang(sample);

    let html = `<table class="diff-table">
      <tr>
        <th style="width:5%"></th>
        <th style="width:38%;">A - Texto/c√≥digo original</th>
        <th style="width:6%"></th>
        <th style="width:38%;">B - Texto/c√≥digo novo/alterado</th>
        <th style="width:18%;">A√ß√µes</th>
      </tr>`;

    for (let i = 0; i < maxLen; i++) {
      let choice = (mergeChoices[i]?.choice) || "both";
      let editA = mergeChoices[i]?.editA || false;
      let editB = mergeChoices[i]?.editB || false;

      let aLine = editA ? mergeChoices[i]?.a : (aLines[i] ?? "");
      let bLine = editB ? mergeChoices[i]?.b : (bLines[i] ?? "");

      let clsA = "diff-equal", clsB = "diff-equal";
      let valA = aLine, valB = bLine;

      if (aLine === bLine && aLine !== "") {
        clsA = clsB = "diff-equal";
      } else if (aLine === "" && bLine !== "") {
        clsA = "diff-only-a"; clsB = "diff-only-b";
      } else if (bLine === "" && aLine !== "") {
        clsA = "diff-only-a"; clsB = "diff-only-b";
      } else if (aLine !== bLine) {
        clsA = "diff-diff-a"; clsB = "diff-diff-b";
        if (compareMode === "palavra") [valA, valB] = diffWords(aLine, bLine);
        else if (compareMode === "caractere") [valA, valB] = diffChars(aLine, bLine);
        else [valA, valB] = diffWords(aLine, bLine);
      }

      mergeChoices[i] = {a: aLine, b: bLine, choice, idx:i, editA, editB};

      let actionBtns = '';
      if (aLine !== bLine) {
        actionBtns = `
          <div class="merge-actions">
            <button class="keepA${choice==='a'?' selected':''}" onclick="setMergeChoice(${i},'a');return false;">A</button>
            <button class="keepB${choice==='b'?' selected':''}" onclick="setMergeChoice(${i},'b');return false;">B</button>
            <button class="keepBoth${choice==='both'?' selected':''}" onclick="setMergeChoice(${i},'both');return false;">Ambos</button>
            <button class="copyToA" title="Copiar B para A" onclick="copyBtoA(${i});return false;">‚Üê</button>
            <button class="copyToB" title="Copiar A para B" onclick="copyAtoB(${i});return false;">‚Üí</button>
            <button class="editBtn" title="Editar" onclick="editLine(${i});return false;">‚úèÔ∏è Editar</button>
          </div>`;
      }

      let displayA, displayB;
      if (editA) {
        displayA = `<input class="editField" id="editA${i}" value="${escapeHtml(aLine)}" onblur="saveEdit(${i},'a')" />`;
      } else if (/<del |<ins /.test(valA)) {
        displayA = valA || "&nbsp;";
      } else {
        displayA = `<pre class="code-view language-${lang}">${highlightLine(valA||"", lang)||"&nbsp;"}</pre>`;
      }

      if (editB) {
        displayB = `<input class="editField" id="editB${i}" value="${escapeHtml(bLine)}" onblur="saveEdit(${i},'b')" />`;
      } else if (/<del |<ins /.test(valB)) {
        displayB = valB || "&nbsp;";
      } else {
        displayB = `<pre class="code-view language-${lang}">${highlightLine(valB||"", lang)||"&nbsp;"}</pre>`;
      }

      html += `<tr>
        <td class="line-no">${i+1}</td>
        <td class="${clsA}" id="cellA${i}">${displayA}</td>
        <td class="line-no">${i+1}</td>
        <td class="${clsB}" id="cellB${i}">${displayB}</td>
        <td>${actionBtns}</td>
      </tr>`;
    }
    html += "</table>";
    setTimeout(() => Prism.highlightAll(), 0);
    return html;
  }

  function setMergeChoice(idx, type) {
    mergeChoices[idx].choice = type;
    renderDiff();
    updateMergeResult();
  }

  function updateMergeResult() {
    let result = [];
    for(const line of mergeChoices) {
      if(line.choice === "a") { if(line.a) result.push(line.a);}
      else if(line.choice === "b") { if(line.b) result.push(line.b);}
      else if(line.choice === "both") {
        if(line.a && line.b && line.a!==line.b) result.push(line.a, line.b);
        else if(line.a) result.push(line.a);
        else if(line.b) result.push(line.b);
      }
    }
    let sample = result.join('\n').slice(0,1500);
    let lang = detectLang(sample);
    let mergeHtml = `<pre class="code-view language-${lang}">${highlightLine(result.join('\n'), lang)}</pre>`;
    document.getElementById('mergeResult').innerHTML = mergeHtml;
    setTimeout(() => Prism.highlightAll(), 0);
  }

  function editLine(idx) {
    mergeChoices[idx].editA = true;
    mergeChoices[idx].editB = true;
    renderDiff();
    setTimeout(() => {
      document.getElementById(`editA${idx}`)?.focus();
    }, 60);
  }

  function saveEdit(idx, side) {
    const el = document.getElementById(`edit${side.toUpperCase()}${idx}`);
    if (!el) return;
    const val = el.value;
    mergeChoices[idx][side] = val;
    mergeChoices[idx][`edit${side.toUpperCase()}`] = false;
    renderDiff();
    updateMergeResult();
  }

  function copyBtoA(idx) {
    mergeChoices[idx].a = mergeChoices[idx].b;
    setMergeChoice(idx, 'a');
  }
  function copyAtoB(idx) {
    mergeChoices[idx].b = mergeChoices[idx].a;
    setMergeChoice(idx, 'b');
  }

  function escapeHtml(str) {
    return str.replace(/[&<>"']/g, function(tag) {
      const charsToReplace = { 
        '&': '&amp;', 
        '<': '&lt;', 
        '>': '&gt;', 
        '"': '&quot;',
        "'": '&#39;'
      };
      return charsToReplace[tag] || tag;
    });
  }

  function renderDiff() {
    const a = document.getElementById('txtA').value;
    const b = document.getElementById('txtB').value;
    document.getElementById('diffResult').innerHTML = diffLineByLine(a, b);
    setTimeout(() => Prism.highlightAll(), 0);
  }

  function detectLang(str) {
    if (/^\s*[\{\[]/.test(str) && /[\}\]]\s*$/.test(str)) return "json";
    if (/<[a-zA-Z!?]/.test(str)) {
      if (str.trim().startsWith('<!DOCTYPE html') || /<html[\s>]/i.test(str)) return "markup";
      return "xml-doc";
    }
    if (/function |const |let |var |=>/.test(str)) return "javascript";
    return "none";
  }

  function highlightLine(str, lang) {
    if (!str || lang==="none") return str.replace(/</g,"&lt;").replace(/>/g,"&gt;");
    if (Prism.languages[lang])
      return Prism.highlight(str, Prism.languages[lang], lang);
    return str.replace(/</g,"&lt;").replace(/>/g,"&gt;");
  }

  document.getElementById('btnCompare').onclick = () => {
    mergeChoices = []; // limpa para evitar bug ao trocar textos/formatos!
    renderDiff();
    updateMergeResult();
  };

  document.getElementById('btnCopy').onclick = () => {
    let txt = "";
    for(const line of mergeChoices) {
      if(line.choice === "a") { if(line.a) txt += line.a+"\n";}
      else if(line.choice === "b") { if(line.b) txt += line.b+"\n";}
      else if(line.choice === "both") {
        if(line.a && line.b && line.a!==line.b) txt += line.a+"\n"+line.b+"\n";
        else if(line.a) txt += line.a+"\n";
        else if(line.b) txt += line.b+"\n";
      }
    }
    if(txt) {
      navigator.clipboard.writeText(txt.trim());
      alert("Resultado copiado!");
    }
  };

  window.setMergeChoice = setMergeChoice;
  window.editLine = editLine;
  window.saveEdit = saveEdit;
  window.copyBtoA = copyBtoA;
  window.copyAtoB = copyAtoB;

  document.getElementById('txtA').addEventListener('input', () => {
    mergeChoices = [];
    renderDiff();
    updateMergeResult();
  });
  document.getElementById('txtB').addEventListener('input', () => {
    mergeChoices = [];
    renderDiff();
    updateMergeResult();
  });

  // Inicializa√ß√£o
  renderDiff();
  updateMergeResult();

  // üîí Opcional: eu recomendo remover este bloco, mas deixei comentado.
  /*
  document.addEventListener('keydown', e => {
    if (
      e.keyCode === 123 || // F12
      (e.ctrlKey && e.shiftKey && (e.keyCode === 73 || e.keyCode === 74)) || // Ctrl+Shift+I / Ctrl+Shift+J
      (e.ctrlKey && e.keyCode === 85) // Ctrl+U
    ) {
      e.preventDefault();
    }
  });
  document.addEventListener('contextmenu', e => e.preventDefault());
  */
</script>
